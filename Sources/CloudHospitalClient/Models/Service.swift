//
// Service.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct Service: Codable, Hashable {

    public var id: UUID?
    public var name: String?
    public var normalizedName: String?
    public var slug: String?
    public var description: String?
    public var content: String?
    public var normalizedDescription: String?
    public var hospitalId: UUID?
    public var specialtyId: UUID?
    public var packageServiceId: UUID?
    public var hospitalSpecialty: HospitalSpecialty?
    public var procedure: Procedure?
    public var serviceCategoryId: UUID?
    public var minPrice: Double?
    public var maxPrice: Double?
    public var priceReuqest: Bool?
    public var order: Int?
    public var medias: [Media]?
    public var auditableEntity: AuditableEntity?

    public init(id: UUID? = nil, name: String? = nil, normalizedName: String? = nil, slug: String? = nil, description: String? = nil, content: String? = nil, normalizedDescription: String? = nil, hospitalId: UUID? = nil, specialtyId: UUID? = nil, packageServiceId: UUID? = nil, hospitalSpecialty: HospitalSpecialty? = nil, procedure: Procedure? = nil, serviceCategoryId: UUID? = nil, minPrice: Double? = nil, maxPrice: Double? = nil, priceReuqest: Bool? = nil, order: Int? = nil, medias: [Media]? = nil, auditableEntity: AuditableEntity? = nil) {
        self.id = id
        self.name = name
        self.normalizedName = normalizedName
        self.slug = slug
        self.description = description
        self.content = content
        self.normalizedDescription = normalizedDescription
        self.hospitalId = hospitalId
        self.specialtyId = specialtyId
        self.packageServiceId = packageServiceId
        self.hospitalSpecialty = hospitalSpecialty
        self.procedure = procedure
        self.serviceCategoryId = serviceCategoryId
        self.minPrice = minPrice
        self.maxPrice = maxPrice
        self.priceReuqest = priceReuqest
        self.order = order
        self.medias = medias
        self.auditableEntity = auditableEntity
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case name
        case normalizedName
        case slug
        case description
        case content
        case normalizedDescription
        case hospitalId
        case specialtyId
        case packageServiceId
        case hospitalSpecialty
        case procedure
        case serviceCategoryId
        case minPrice
        case maxPrice
        case priceReuqest
        case order
        case medias
        case auditableEntity
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(normalizedName, forKey: .normalizedName)
        try container.encodeIfPresent(slug, forKey: .slug)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(content, forKey: .content)
        try container.encodeIfPresent(normalizedDescription, forKey: .normalizedDescription)
        try container.encodeIfPresent(hospitalId, forKey: .hospitalId)
        try container.encodeIfPresent(specialtyId, forKey: .specialtyId)
        try container.encodeIfPresent(packageServiceId, forKey: .packageServiceId)
        try container.encodeIfPresent(hospitalSpecialty, forKey: .hospitalSpecialty)
        try container.encodeIfPresent(procedure, forKey: .procedure)
        try container.encodeIfPresent(serviceCategoryId, forKey: .serviceCategoryId)
        try container.encodeIfPresent(minPrice, forKey: .minPrice)
        try container.encodeIfPresent(maxPrice, forKey: .maxPrice)
        try container.encodeIfPresent(priceReuqest, forKey: .priceReuqest)
        try container.encodeIfPresent(order, forKey: .order)
        try container.encodeIfPresent(medias, forKey: .medias)
        try container.encodeIfPresent(auditableEntity, forKey: .auditableEntity)
    }
}

